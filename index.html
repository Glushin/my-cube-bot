<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Cube Navigation</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; -webkit-user-select: none; }
        canvas { display: block; outline: none; -webkit-tap-highlight-color: transparent; }

        /* Стили для стрелок */
        .controls {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10; /* Поверх канваса */
        }

        .arrow {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.15); /* Полупрозрачный фон */
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .arrow:active {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        /* Чтобы на мобильных не выделялось синим при тапе */
        .arrow { -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>
    <!-- UI Элементы: Стрелки -->
    <div class="controls">
        <div id="btn-up" class="arrow">▲</div>
        <div id="btn-down" class="arrow">▼</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Инициализация сцены
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.035);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;

        // Свет
        scene.add(new THREE.AmbientLight(0x404040, 2));
        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // 2. Создание Куба
        const cubeGroup = new THREE.Group();
        const geometry = new THREE.BoxGeometry(2, 0.6, 2);

        // Функция для создания материала (чтобы у каждого куска был свой отдельный материал)
        function createMaterial() {
            return new THREE.MeshPhysicalMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.3, // Базовая прозрачность
                roughness: 0.1,
                metalness: 0.1,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
        }

        // Создаем слайсы
        const topSlice = new THREE.Mesh(geometry, createMaterial());
        topSlice.position.y = 0.7;

        const midSlice = new THREE.Mesh(geometry, createMaterial());
        midSlice.position.y = 0;

        const botSlice = new THREE.Mesh(geometry, createMaterial());
        botSlice.position.y = -0.7;

        // Важно: Порядок в массиве: [Низ, Середина, Верх] (как просили для стрелки Вверх)
        const slices = [botSlice, midSlice, topSlice];

        // Добавляем слайсы и грани в группу
        slices.forEach(mesh => {
            cubeGroup.add(mesh);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 }));
            mesh.add(line);
        });

        scene.add(cubeGroup);

        // 3. Точки (они не должны менять яркость, поэтому отдельные материалы)
        const dotGeo = new THREE.SphereGeometry(0.12, 16, 16);

        // Красная (Верхний угол)
        const redDot = new THREE.Mesh(dotGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 }));
        redDot.position.set(0.9, 0.9, 0.9);
        cubeGroup.add(redDot);

        // Зеленая (Низ центр)
        const greenDot = new THREE.Mesh(dotGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 }));
        greenDot.position.set(0, -0.7, 0);
        cubeGroup.add(greenDot);


        // ==========================================
        // ЛОГИКА НАВИГАЦИИ
        // ==========================================

        let activeIndex = -1; // -1 = Ничего не выбрано (все синие)

        function updateVisuals() {
            // Если ничего не выбрано (-1)
            if (activeIndex === -1) {
                slices.forEach(slice => {
                    slice.material.opacity = 0.3;     // Стандартная прозрачность
                    slice.material.color.set(0x0088ff); // Стандартный синий
                });
                return;
            }

            // Если что-то выбрано
            slices.forEach((slice, index) => {
                if (index === activeIndex) {
                    // ВЫБРАННЫЙ: Ярче
                    slice.material.opacity = 0.7;
                    slice.material.color.set(0x33AAFF); // Чуть светлее
                } else {
                    // ОСТАЛЬНЫЕ: Темные
                    slice.material.opacity = 0.05;
                }
            });
        }

        // Кнопка ВВЕРХ
        document.getElementById('btn-up').addEventListener('click', (e) => {
            e.stopPropagation(); // Чтобы клик не ушел на канвас
            if (activeIndex === -1) {
                activeIndex = 0; // Начинаем с нижнего
            } else {
                activeIndex++;
                if (activeIndex > 2) activeIndex = 0; // Цикл: Верх -> Низ
            }
            updateVisuals();
        });

        // Кнопка ВНИЗ
        document.getElementById('btn-down').addEventListener('click', (e) => {
            e.stopPropagation();
            if (activeIndex === -1) {
                activeIndex = 2; // Начинаем с верхнего (интуитивно)
            } else {
                activeIndex--;
                if (activeIndex < 0) activeIndex = 2; // Цикл: Низ -> Верх
            }
            updateVisuals();
        });

        // ЛОГИКА КЛИКА ВНЕ КУБА (Сброс)
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            // Если кликнули по стрелкам, этот код не сработает (из-за e.stopPropagation выше),
            // но на всякий случай проверяем таргет
            if (event.target.closest('.controls')) return;

            // Вычисляем координаты клика для Raycaster
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Проверяем, пересекает ли луч наши слайсы
            const intersects = raycaster.intersectObjects(slices);

            // Если пересечений нет (клик в молоко) -> Сбрасываем
            if (intersects.length === 0) {
                activeIndex = -1;
                updateVisuals();
            }
        });


        // Setup Telegram
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();

        // 4. Анимация
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            // Вращение
            cubeGroup.rotation.y += 0.003;

            // Мигание точек (не зависит от выделения куба)
            redDot.material.opacity = (Math.sin(time * 6) + 1) / 2;
            greenDot.material.opacity = (Math.sin(time * 3) + 1) / 2;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>